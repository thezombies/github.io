# 아는 것이 무엇인가?


1. 데이터 불러오기

> 개발환경 만들기
  >>  pd.options.display.max_columns = 
  >>  pd.options.display.max_rows = 
  
> 데이터 불러오기 (특정 컬럼만 불러오기)
> 인덱스 지정하기
  > df.set_index('')
  > df.reset_index('')
  
> 톺아보기
  


2. 데이터 정제하기

> 컬럼명 바꾸기
  >> df.rename({'a':'b'), axis = 'columns')
  >> df.columns = df.columns.str.replace('','')
  
  
> 데이터타입 바꾸기
> 결측치처리 
  >> def > apply 하는데, np에서, np.nan / np.fillna() / np.fillna(0)
  change all
  >> df['col_new'] = df['col'].replace('a',np.nan)
  
  case by case
  >> df.loc[df['col'] > 0,"target_col"] = np.nan
  
  
  


> apply로 문자형 바꾸기
  >> def if a == '' : return '' > apply 
  
> apply로 연산 적용하기
  >> 데이터를 분류하기 (ref. CASE WHEN)

> apply for many x by using lambda
  >> def sample(x,y):
      return x+y
      
     df['new'] = df.apply(lambda x : sample(df["x"]i, df["y"]), axis =1) # pandas에서 axis = 0은 index, 1은 column내 values 즉 series를 뜻한다.

  >> lambda는 필터로도 기능한다
      e.g. df['sample'] = df.apply(lambda x : return Z if x is none, axis = 1)

> dataframe에서 null을 비교하는 걸 isnull()이라고 한다면,
  >> value에서의 nan을 판별하는 건, x != x였다...(is None이기도 하는데, 결국 apply에서는 적용되지 못했다)
  >> 방법은 replace(np.nan, -1) 로 하고, -1을 이용해 함수를 만들고 > apply를 하는 것.
  >> 요 간단한 것 때문에, 몇 시간을 잡아먹었는지.......ㅠㅠ

> dataframe에서 between은
  >> vlaue 에서는 10 <= value < 12 이다
  
  def invalid(status, height, initial_weight, lowest_weight, target_weight, BMI, loss_goal):
    if status != 'completed':
        return False
    elif (status == "compelted") \
        & (height is None) & (initial_weight is None) & (lowest_weight is None)\
        & (140<= height <= 200)&(18.5<= BMI <= 30)&(loss_goal < 0):
           return False
    else:
           return True

> progress_apply를 써서, 진행도를 바그래프 및 시간으로 정리하는 법
 >> from tqdm import tqdm
     tqdm.pandas 후에, progress_apply처리
     
     
> pivot table에 대하여 == pd.pivot_table(df, index = , values, columns , aggfunc = )
     : pd.pivot_table의 방법과 groupby()의 방법이 있습니다.
     : 전자는 모양, 후자는 속도에 강점이 있음.
     : pd.pivot_table 의 결과물 역시, DataFrame임.
      > 즉, 컬럼을 가공 및 결합하여, 다른 컬럼을 만들 수 있음 >> 그래서, Total이나, Conversion을 쉽게 구할 수 있음.
      > 다만, groupby와 섞어서 쓰면, 보다 쉽게 접근할 수 있을 것 같음
      >> 그래서, groupby 역시 친숙해지길.
      

> Concat에 대하여
     : concat은 행과 행의 결합 / 열과 열의 결합을 할 때 씀 ( concat( [t1,t2], axis = 1, join = ) #  axis 가 0이면 행(index니까), 1이면 컬럼
     : 이 때, 


> 전치행렬 T
     : 복수의 컬럼명(one hot encoding시)을 하나의 컬럼값으로 만드는 법!
     
      a = pd.pivot_table(good_coach, index = ['Status'], values = good_coach_coloumns,  aggfunc='sum', fill_value= 0)
      > a.T


> 데이터 타입에 대하여
: 날짜형  pd.to_date(df[''])

> 정렬에 대하여
: .sort(by = , ascending = True)
